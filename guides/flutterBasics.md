# Flutter Basics
- Create a new project with `flutter create flutter_basic_app`
- open `Android Studio` > open an existing project and select android folder
  - we are only using `Android Studio` for emulator
  - craete a new device for the project and click play
- VS Code 
  - User terminal to run the project
  - You can run project with or without debugging mode
    - Run > Start Debugging
    - Run > Without Debugging > select > Dart & Flutter. This will build the project with the help of SDK.
    - You also have access to control bar
- Go back to emulator and see your app is loaded in it

## Project folder structure
- .idea - holds configuration for android studio. No need to change as we are not using that IDE.
- .vscode - holds configuration for VS Code IDE
- android - This is the folder where Android app will be compiled to its native code. You shouldn't need to change anything in there.
- iOS - This is the folder where iOS app will be compiled to its native code. You shouldn't need to change anything in there. This folder is not available on windows as you can't build an iOS app from windows machine. This is in essence the xcode project which is created and managed by flutter. 
- build - this holds the output of your flutter application. This is generated and managed by flutter SDK so you shouldn't have to make any changes there.
- lib - lib is the coding folder (important for us) for us where we will be craeting our dart files and craeting our project code
- test - is for writing test cases for the project
- .metadata - again this file is nmanaged by flutter and save some information that widgets need to build our application correectly
- .packages - again generated by Flutter SDK  and to mannge internal dependency. Don't change and don't remove.
- <AppName>.iml - again generated by Flutter SDK and to mannge internal dependency and some project settings. We will not be changing this file.
- pubspec.lock / pubspec.yml - we will be using as to manage 3rd party dependencies that we need for our project, configure fonts, images etc. Code will be written in yml and will generate the relevant .lock file (but holds more details information ), same as package.json config file in a node project


## Dart
- Dart is a typed language which helps maintain the incoming and resul ting data types and catches any errors early on
  - Types:
    - Text
      -String
    - Number
      - fntegers - numbers without decimal
      - floats / double - decimal numbers (can also accept a whole numbe and converts it to double (as a decimal) to return the value)
      - num - aloows both  int and doubles
- variable can be assigned with var or a type keyword
- void is a type to show that a function returns nothing
- main is a special function name as its get called automatically in a file 
- main.dart file is the main file that gets called automatically when the app starts so when you put main function in amin.dart will be the first function your app calls
- use camel cased function names, use the name to describe its fucntionaly to make it easier for others to understand it
- Dart is a object oriented language. Everything in dart is a object, meaning everything is in object data structure which is used by dart internally, ie 1 is also an object which has some additional info. Object also helps the relation between different datas, ie name and age individually may not be obviously related if stored individually.
  - To create an object you need to create a blueprint of it to tell dart how object looks like, this can be done by `class`. Give a name to a class starting with a capital letter
  ```
    class Person {
      String name = 'Max';
      int age = 30; 
    }
  ```
  - the you will craete an instance of that class Person by `var p1 = Person()` // new keyword with Person is not required in Dart which will instantiate that class instance and the you can access the properties of that class object by `p1.age`
  - class with constructor and named arguments
  ```
    class Person {
      String name = 'Max';
      int age = 30; 
      
      // in dart it doesn't need contructor just need to call it with class namem with named args and default value
      // or pass @required (provided by flutter) with the args to make them required 
      Person({ @required String inputName, @required int age = 30}) { 
        name = inputName;
        this.age = age
      }
    }
    var p1 = Person(age: 31, inputName: 'Manu') // named arguments so no need to remember the position of the passed argument
  
    // shortcut of above class by keeping the properties name same so don't need to manually set their values
    class Person {
      String name = 'Max';
      int age = 30; 
      
      Person({ @required String name, @required int age = 30})
    }
    var p1 = Person(age: 31, name: 'Manu')
  ```
  - any function that belongs to a class should go inside the class as its method instead of sitting outside
```
// 1
void addNumber(int a, double b) {
  print(a + b);
}

// 2
double addNumber(double a, double b) {
  return a + b;
}

void main() { 
  print(addNumber(2, 5.5)); // throws error with 1 as it doesn't return anything
  print(addNumber(2, 5.5)); // 7.5 with 2

  var result = addNumber(2, 5.5); // craeting a variable, it could also be double result = ... as its value type is infered to the variable but its best practise to use var

  for(int i = 0; i < 5; i++) {
    print('Hello ${i + 1}')
  }
}
// OUTPUT
hello 1
hello 2
hello 3
hello 4
hello 5
```
## main.dart
- import widget with `import 'package:flutter/material.dart';` Its created by the flutter team and unlocks a lot of core features to do most of the heavy lifting for creating the app.
  - material widget has a base class which allows you to craete your own widgets
- You need to pass build method into the call which will be called by flutter to draw pixels on the screen and it recieves a param called context (holds meta information) with its special iobject type `BuildContext`
  - build is a method which return a Widget so it needs to be called as `Widget build(BuildContext context) {}` which returns `MaterialApp()` as a widget and accepts named arguments. MaterialApp is a class and accepts args as per contructor methods. StatelessWidget or StatefulWidget
  ```
    class MyApp extends StatelessWidget {
      Widget build(BuildContext context) {
        return MaterialApp(home: Text('Hello!'));
      }
    }
  ```
  - to draw / render the app app onto the screen we need to call `runApp` method provided by flutter/material package and pass our app class ot it as an argument (with paraenthesis)
  ```
    void main() {
      runApp(MyApp());
    }
    or can be written as 
    void main() => runApp(MyApp());
  ```
  - `@override` method provided by flutter. Add this to clarify that you are not accidentally overrirding some method. In this case `Widget` is provided by StatelessWidget and we are overriding to return our widget.
  ```
  class MyApp extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
      return MaterialApp(home: Text('Hello!'));
    }
  }
  ```
- Marial.dart comes with a baked in helper widget called `Scaffold()` to control how the UI willl look like, appBar is top bar, body is the main content of the page.
  - AppBar: Title method accepts the `Text('my text')` widget which accepts the text 
  - Body: only accepts 1 widget usually build with Layout / invisible widget to structure the page but for now test it with the `Text('my text')` widget which accepts teh text
  - Tip: keep the additional end comma to auto format the code
- Widget Types
  - Output / Visible widgets like Button, Text(), Cards() - interactive / informational
  - Layout / Invisible widgets like, Row(), Column(), ListView() - goive structure to the page
  - Container widgets can be either output / layout depending on the usage, can give structure but also can be styles too 
- any function that belongs to a Widget class should go inside that class as its method instead of sitting outside
- Make sure to pass the `answerQuestion` as a pointer instead of a value by not using it with parenthesis. We are passing the name of the function as a pointer instead od the result of the function
  - without `onPressed` having a valid function button state remains disable
```
 body: Column(
  children: <Widget>[
    Text('This is question!'),
    ElevatedButton(
      child: Text('Answer 1'),
      onPressed: answerQuestion, 
    ),
    ElevatedButton(

or could also be done as 
onPressed: () => print('test);, 
```

### What is state
State is Data/Information used by your App. App state could be authenticated Users, loaded jobs. Widget State is Current User Input, Is a loading spinner being shown?

Widgets can be of two types:
- StatelessWidget
- StatefulWidget

**Stateless** widgets are generally used to just output the data. They recieve data from outside via constructors (external data can change) but these widget don't change data internally. Data gets re-rendered when input data changes.
`Input Data >>>>>> Widget >>>>>> Renders UI`

**Stateful** same as statless widgets data can change externally but it can also change internally. Internal data is known as state. Data gets re-rendered when input data or local state changes. Creating Stateful widget is not as starightforward.
- change `StatelessWidget` to statefulWidget
- You need to create 2 classes, MyApp and MyAppState. When flutter rebuilds MyApp class gets recreated but MyAppState stays persistent which mean when the main widget re-render on the page, the external data changes but internal data doesn't get reset. MyAppState is also extended with the State which is attached to its widget by `State<MyApp>`
- `State<MyApp>` tells that is class belongs to which widget
- StatefulWidget has a craeteState method and returns state based on the MyAppState class
```
class MyApp extends StatefulWidget {
  @override
  State<StatefulWidget> createState() {
    // implements create state
    return MyAppState();
  }
}
```
- to avoid rerendering the whole page everytime the data change (to get performance gain), flutter's state class provide us with setState method which takes an annonymous function and inside its body we can make changes to the data
- setState forces flutter to re-render the UI but not entirely instaed it calls the build of a particular widget so it only updates the relevant UI 
```
class MyApp extends StatefulWidget {
  @override
  State<StatefulWidget> createState() {
    // implements create state
    return MyAppState();
  }
}

class MyAppState extends State<MyApp> {
  var questionIndex = 0;
```
- In Dart to make a class, method or a variable you can prefix it with `_`. So to protect `MyAppState`, `questionIndex` and `answerQuestion` from being accessed from outside files we can name them as `_MyAppState` to make sure they are prviate instead of public.
- general rule of thumb is to have 1 widget per file unless in exceptional case where widgets are related or have dependencies

## question.dart
  - add a question.dart file to separate the re-rendering of question UI, helps with file size control and reusability
  - using class constructor method and adding `final` to avoid the immutable warning, which tells dart that this particular value will not chnage after its initialization. The class question is initialised by its constructor methods.
    - difference between final and const is we know the value of a const variable at the time of writing the code (compile time constant which is also as runtime constant because it never changes ) but with final we don't. Its a runtime constant value and also it depends on the instance of that class.
    - const can be given to a variable name and its value so whne Dart stores the address of the data in the memory it know it it can be overwritten or not.
    `const x = const [...]`
  - import question.dart into main and replace the Text widget with it
  ```
  import 'package:flutter/material.dart';

  class Question extends StatelessWidget {
    final String questionText;

    Question(this.questionText);

    @override
    Widget build(BuildContext context) {
      return Text(questionText);
    }
  }
  ```

## answer.dart
Extracted answer into its own stateless widget file and pass the function as a pointer (meaning without ())
```
import 'package:flutter/material.dart';

class Answer extends StatelessWidget {
  final Function selectHandler;

  Answer(this.selectHandler);

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      child: ElevatedButton(
        // color: Colors.blue,
        // style: ButtonStyle(
        //     backgroundColor: MaterialStateProperty.all<Color>(Colors.blue)),
        style: ElevatedButton.styleFrom(
          primary: Colors.blue,
          textStyle: TextStyle(color: Colors.white),
        ),
        child: Text('Answer 1'),
        onPressed: selectHandler,
      ),
    );
  }
}
```

### added map and iterating over it
```
var questions = [
      {
        'questionText': 'What\'s your favourite color?',
        'answers': ['Red', 'Yellow', 'White', 'Black']
      },
      {
        'questionText': 'What\'s your favourite animal?',
        'answers': ['Rabbit', 'Dog', 'Elephant', 'Tiger']
      },
      {
        'questionText': 'What\'s your favourite tutor?',
        'answers': ['Max', 'Andrew', 'Dimitri', 'Chris']
      }
    ];
 return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: Text('My First App\'s title'),
        ),
        body: Column(
          children: [
            Question(questions[_questionIndex]['questionText']),
            ...(questions[_questionIndex]['answers'] as List<String>)
                // Note: map doesn't alter the original questions list instead to makes copy of it and retuns a new list
                .map((answer) {
              return Answer(_answerQuestion, answer);
            }).toList()
            // Answer(_answerQuestion),
            // Answer(_answerQuestion),
            // Answer(_answerQuestion),
          ],
        ),
      ),
    );
```

## Debugging and Actual Device Testing
**Android**
- Settings >> Developer Options >> Tap on build number 7 times >> Developer options >> USB Debugging turn on
- connect your device with USB cable >> Rebuild your app >> VS Code >> Select a device o use, should show your device 

**iOS**
- Simulator
  - Your Flutter app code >> iOS folder >> open .xcodeproj file in xcode
  - click on `Runner` in the left bar >> Signing & Capabilities >> add your apple account
    - You need apple developer account to activate this [https://developer.apple.com/](https://developer.apple.com/)
    - You need to pay a fee to publish your apple app but for developing / testing you don't need to pay any fee
  - once your account is set-up, you cna run your code either via emulator or with an actual device
  - VS Code terminal command to open emulator `open -a Simulator.app` and rebuild your project by `Run >> Run without debugger` to open your app in the emulator device
- Actual device with USB Cable
  - Connect your device with USB cable, then either selcet the device from xcode or vs code (may not work from vs code)

- Test on rotation with settings
- You can set you device to use hardware keyboard

**Errors**
- watchout for missing `;`
- look at application debugger
- user `print(...code...)` to see what's printed in the console (tip: read error from the top)
- run you app in Debug mode, set breakpoints and analyse
  - don't use debugger mode all the time due to performance
  - use mini-toolbar to play or step into
- Layout and performance degugging
  - VS code - `cmd + shift + p` >> type: Dart: dev tools >> choose the device you want to debug >> choose what you wish to debug
  - select `Dev Debug` will open in a browser window with your app's layout
    - choose `select widget mode` to see the debugger on the layout
    - `Debug paint` shows the UI element alignments
    - `Performance Overlay` - to help you understand performance better but there is huge difference ion app performance on debug / production mode
    - `Repaint Rainbow` - is to show which elements are re-rendering on the UI
      - repainting comes from memory and rebuild is more expensive task so repaint is better then rebuild
      - optimization, could be the elements that need repainting can be stored inside an individual widget so it doesn't cause repaint of the parent widgets 
    - `timeline` for recording and test performance and memory leaks, or unused (not-let go of data observations)

### Styles
Container Vs Column
You don't have to use them individually but you can choose to mix and match them.
```
               Container               |                   Column 
______________________________________________________________________________________
- Takes exactly one child widget       | - Takes multiple (unlimited) child widgets
- Rich alignment & styling options     | - Alignment but no styling options
- Flexible width (e.g, child width,    | - Always takes full available width (row)
  available width, ... )               |   / height (column)
- Perfect for custom styling &         | - Must-use if widgets sit next to or above
  alignment                            |    each other
```

Stateful widgets usually get build when their state changes causing UI to update and its child widgets. It can be a performance lag if you cause the whole app to repaint all the time. It could be a good idea to keep your app's homepage as a stateless widget.

**Scrolling**
- wrap Column inside SingleChildScrollView at the body leve for fullpage scrolling
- or add scrolling to a particula widget alone as transactionList widget
- to get the scrolling working wrap Column inside Container with fixed height and then inside SingleChildScrollView
- or you can use ListView instead of SingleChildScrollView and Column

**ListView with lazyload**
- ListView(children: []) = smililar to SingleChildScrollView renders the full list at once and maintains them, Not suitable for large lists
- ListView.builder: []) = not like SingleChildScrollView renders only visible list and renders / build only whats visible (built in lazy load machaism), suitable for large lists
- ListView.builder: []) comes with itemBuider: (builderContext (returns the item), index as int) and itemCount: XYZ.length so it can count upfornt the item that'll be visible

