# Flutter Basics
- Create a new project with `flutter create flutter_basic_app`
- open `Android Studio` > open an existing project and select android folder
  - we are only using `Android Studio` for emulator
  - craete a new device for the project and click play
- VS Code 
  - User terminal to run the project
  - You can run project with or without debugging mode
    - Run > Start Debugging
    - Run > Without Debugging > select > Dart & Flutter. This will build the project with the help of SDK.
    - You also have access to control bar
- Go back to emulator and see your app is loaded in it

## Project folder structure
- .idea - holds configuration for android studio. No need to change as we are not using that IDE.
- .vscode - holds configuration for VS Code IDE
- android - This is the folder where Android app will be compiled to its native code. You shouldn't need to change anything in there.
- iOS - This is the folder where iOS app will be compiled to its native code. You shouldn't need to change anything in there. This folder is not available on windows as you can't build an iOS app from windows machine. This is in essence the xcode project which is created and managed by flutter. 
- build - this holds the output of your flutter application. This is generated and managed by flutter SDK so you shouldn't have to make any changes there.
- lib - lib is the coding folder (important for us) for us where we will be craeting our dart files and craeting our project code
- test - is for writing test cases for the project
- .metadata - again this file is nmanaged by flutter and save some information that widgets need to build our application correectly
- .packages - again generated by Flutter SDK  and to mannge internal dependency. Don't change and don't remove.
- <AppName>.iml - again generated by Flutter SDK and to mannge internal dependency and some project settings. We will not be changing this file.
- pubspec.lock / pubspec.yml - we will be using as to manage 3rd party dependencies that we need for our project, configure fonts, images etc. Code will be written in yml and will generate the relevant .lock file (but holds more details information ), same as package.json config file in a node project


## Dart
- Dart is a typed language which helps maintain the incoming and resul ting data types and catches any errors early on
  - Types:
    - Text
      -String
    - Number
      - fntegers - numbers without decimal
      - floats / double - decimal numbers (can also accept a whole numbe and converts it to double (as a decimal) to return the value)
      - num - aloows both  int and doubles
- variable can be assigned with var or a type keyword
- void is a type to show that a function returns nothing
- main is a special function name as its get called automatically in a file 
- main.dart file is the main file that gets called automatically when the app starts so when you put main function in amin.dart will be the first function your app calls
- use camel cased function names, use the name to describe its fucntionaly to make it easier for others to understand it
- Dart is a object oriented language. Everything in dart is a object, meaning everything is in object data structure which is used by dart internally, ie 1 is also an object which has some additional info. Object also helps the relation between different datas, ie name and age individually may not be obviously related if stored individually.
  - To create an object you need to create a blueprint of it to tell dart how object looks like, this can be done by `class`. Give a name to a class starting with a capital letter
  ```
    class Person {
      String name = 'Max';
      int age = 30; 
    }
  ```
  - the you will craete an instance of that class Person by `var p1 = Person()` // new keyword with Person is not required in Dart which will instantiate that class instance and the you can access the properties of that class object by `p1.age`
  - class with constructor and named arguments
  ```
    class Person {
      String name = 'Max';
      int age = 30; 
      
      // in dart it doesn't need contructor just need to call it with class namem with named args and default value
      // or pass @required (provided by flutter) with the args to make them required 
      Person({ @required String inputName, @required int age = 30}) { 
        name = inputName;
        this.age = age
      }
    }
    var p1 = Person(age: 31, inputName: 'Manu') // named arguments so no need to remember the position of the passed argument
  
    // shortcut of above class by keeping the properties name same so don't need to manually set their values
    class Person {
      String name = 'Max';
      int age = 30; 
      
      Person({ @required String name, @required int age = 30})
    }
    var p1 = Person(age: 31, name: 'Manu')
  ```
  - any function that belongs to a class should go inside the class as its method instead of sitting outside
```
// 1
void addNumber(int a, double b) {
  print(a + b);
}

// 2
double addNumber(double a, double b) {
  return a + b;
}

void main() { 
  print(addNumber(2, 5.5)); // throws error with 1 as it doesn't return anything
  print(addNumber(2, 5.5)); // 7.5 with 2

  var result = addNumber(2, 5.5); // craeting a variable, it could also be double result = ... as its value type is infered to the variable but its best practise to use var

  for(int i = 0; i < 5; i++) {
    print('Hello ${i + 1}')
  }
}
// OUTPUT
hello 1
hello 2
hello 3
hello 4
hello 5
```
## main.dart
- import widget with `import 'package:flutter/material.dart';` Its created by the flutter team and unlocks a lot of core features to do most of the heavy lifting for creating the app.
  - material widget has a base class which allows you to craete your own widgets
- You need to pass build method into the call which will be called by flutter to draw pixels on the screen and it recieves a param called context (holds meta information) with its special iobject type `BuildContext`
  - build is a method which return a Widget so it needs to be called as `Widget build(BuildContext context) {}` which returns `MaterialApp()` as a widget and accepts named arguments. MaterialApp is a class and accepts args as per contructor methods. StatelessWidget or StatefulWidget
  ```
    class MyApp extends StatelessWidget {
      Widget build(BuildContext context) {
        return MaterialApp(home: Text('Hello!'));
      }
    }
  ```
  - to draw / render the app app onto the screen we need to call `runApp` method provided by flutter/material package and pass our app class ot it as an argument (with paraenthesis)
  ```
    void main() {
      runApp(MyApp());
    }
    or can be written as 
    void main() => runApp(MyApp());
  ```
  - `@override` method provided by flutter. Add this to clarify that you are not accidentally overrirding some method. In this case `Widget` is provided by StatelessWidget and we are overriding to return our widget.
  ```
  class MyApp extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
      return MaterialApp(home: Text('Hello!'));
    }
  }
  ```
- Marial.dart comes with a baked in helper widget called `Scaffold()` to control how the UI willl look like, appBar is top bar, body is the main content of the page.
  - AppBar: Title method accepts the `Text('my text')` widget which accepts the text 
  - Body: only accepts 1 widget usually build with Layout / invisible widget to structure the page but for now test it with the `Text('my text')` widget which accepts teh text
  - Tip: keep the additional end comma to auto format the code
- Widget Types
  - Output / Visible widgets like Button, Text(), Cards() - interactive / informational
  - Layout / Invisible widgets like, Row(), Column(), ListView() - goive structure to the page
  - Container widgets can be either output / layout depending on the usage, can give structure but also can be styles too 
- any function that belongs to a Widget class should go inside that class as its method instead of sitting outside
- Make sure to pass the `answerQuestion` as a pointer instead of a value by not using it with parenthesis. We are passing the name of the function as a pointer instead od the result of the function
  - without `onPressed` having a valid function button state remains disable
```
 body: Column(
  children: <Widget>[
    Text('This is question!'),
    ElevatedButton(
      child: Text('Answer 1'),
      onPressed: answerQuestion, 
    ),
    ElevatedButton(

or could also be done as 
onPressed: () => print('test);, 
```

### What is state
State is Data/Information used by your App. App state could be authenticated Users, loaded jobs. Widget State is Current User Input, Is a loading spinner being shown?

Widgets can be of two types:
- StatelessWidget
- StatefulWidget

**Stateless** widgets are generally used to just output the data. They recieve data from outside via constructors (external data can change) but these widget don't change data internally. Data gets re-rendered when input data changes.
`Input Data >>>>>> Widget >>>>>> Renders UI`

**Stateful** same as statless widgets data can change externally but it can also change internally. Internal data is known as state. Data gets re-rendered when input data or local state changes. Creating Stateful widget is not as starightforward.
- change `StatelessWidget` to statefulWidget
- You need to create 2 classes, MyApp and MyAppState. When flutter rebuilds MyApp class gets recreated but MyAppState stays persistent which mean when the main widget re-render on the page, the external data changes but internal data doesn't get reset. MyAppState is also extended with the State which is attached to its widget by `State<MyApp>`
- `State<MyApp>` tells that is class belongs to which widget
- StatefulWidget has a craeteState method and returns state based on the MyAppState class
```
class MyApp extends StatefulWidget {
  @override
  State<StatefulWidget> createState() {
    // implements create state
    return MyAppState();
  }
}
```
- to avoid rerendering the whole page everytime the data change (to get performance gain), flutter's state class provide us with setState method which takes an annonymous function and inside its body we can make changes to the data
- setState forces flutter to re-render the UI but not entirely instaed it calls the build of a particular widget so it only updates the relevant UI 
```
class MyApp extends StatefulWidget {
  @override
  State<StatefulWidget> createState() {
    // implements create state
    return MyAppState();
  }
}

class MyAppState extends State<MyApp> {
  var questionIndex = 0;
```
- In Dart to make a class, method or a variable you can prefix it with `_`. So to protect `MyAppState`, `questionIndex` and `answerQuestion` from being accessed from outside files we can name them as `_MyAppState` to make sure they are prviate instead of public.
- general rule of thumb is to have 1 widget per file unless in exceptional case where widgets are related or have dependencies

## question.dart
  - add a question.dart file to separate the re-rendering of question UI.
  - useing class constructor method and adding `final` to avoid the immutable warning, which tells dart that this particular value will not chnage after its initialization. The class question is initialised by its constructor methods.
  - import question.dart into main and replace the Text widget with it
  ```
  import 'package:flutter/material.dart';

  class Question extends StatelessWidget {
    final String questionText;

    Question(this.questionText);

    @override
    Widget build(BuildContext context) {
      return Text(questionText);
    }
  }
  ```